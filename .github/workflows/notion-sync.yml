name: Notion to Markdown Sync

on:
  schedule:
    - cron: '0 0 * * *' # Runs daily at midnight
  workflow_dispatch: # Allows manual triggering

permissions:
  contents: write

jobs:
  sync-notion:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: |
          npm init -y
          npm install notion-to-md @notionhq/client

      - name: Create conversion script
        run: |
          cat > convert.js << 'EOL'
          import { NotionToMarkdown } from "notion-to-md";
          import { Client } from "@notionhq/client";
          import { promises as fs } from 'fs';
          import path from 'path';
          import { fileURLToPath } from 'url';

          const __dirname = path.dirname(fileURLToPath(import.meta.url));
          const notion = new Client({ auth: process.env.NOTION_TOKEN });
          const n2m = new NotionToMarkdown({ notionClient: notion });

          function slugify(title){
            return String(title||'')
              .toLowerCase()
              .normalize('NFKD')
              .replace(/[\u0300-\u036f]/g,'')
              .replace(/[^a-z0-9]+/g,'-')
              .replace(/^-+|-+$/g,'')
              .replace(/-+/g,'-');
          }

          async function listChildPageBlocks(pageId){
            const collected = [];
            let cursor = undefined;
            do {
              const res = await notion.blocks.children.list({ block_id: pageId, start_cursor: cursor });
              collected.push(...res.results.filter(b => b.type === 'child_page'));
              cursor = res.has_more ? res.next_cursor : undefined;
            } while(cursor);
            return collected;
          }

          async function getSubpages(pageId){
            try {
              const pages = await listChildPageBlocks(pageId);
              console.log('Found ' + pages.length + ' direct subpages under root');
              pages.forEach(p => console.log('  - ' + p.child_page?.title + ' (' + p.id + ')'));
              return pages;
            } catch(e){
              console.error('Error fetching subpages', e); return [];
            }
          }

          async function getPageTitle(pageId){
            try {
              const page = await notion.pages.retrieve({ page_id: pageId });
              return page.properties?.title?.title?.[0]?.plain_text || page.properties?.Name?.title?.[0]?.plain_text || 'Untitled';
            } catch(e){ return 'Untitled'; }
          }

          async function convertPageToMarkdown(pageId, outPath, explicitTitle, filterChildPages=false){
            try {
              let mdblocks = await n2m.pageToMarkdown(pageId);
              if(filterChildPages){
                // Remove child_page blocks so they are handled separately
                mdblocks = mdblocks.filter(b => b.type !== 'child_page');
              }
              const mdString = n2m.toMarkdownString(mdblocks);
              const title = explicitTitle || await getPageTitle(pageId);
              const slug = slugify(title) || 'untitled';
              const frontmatter = '---\n'
                + 'title: "' + title.replace(/"/g,'\\"') + '"\n'
                + 'date: "' + new Date().toISOString() + '"\n'
                + 'slug: "' + slug + '"\n'
                + '---\n\n';
              const full = frontmatter + mdString.parent;
              let write = true;
              if(await fs.access(outPath).then(()=>true).catch(()=>false)){
                const existing = await fs.readFile(outPath,'utf-8');
                write = existing !== full;
              }
              if(write){
                await fs.mkdir(path.dirname(outPath), { recursive: true });
                await fs.writeFile(outPath, full);
                console.log('[WRITE] ' + outPath);
              } else {
                console.log('[SKIP ] ' + outPath + ' (no changes)');
              }
              return { title, slug, path: outPath };
            } catch(e){
              console.error('[ERROR] Convert failed for ' + pageId, e); return null;
            }
          }

          async function main(){
            const rootDir = 'src/content';
            const projectsDir = path.join(rootDir, 'projects');
            await fs.mkdir(projectsDir, { recursive: true });
            const processed = new Set();

            console.log('== Converting root page ==');
            const baseTitle = await getPageTitle(process.env.NOTION_PAGE_ID);
            const baseResult = await convertPageToMarkdown(
              process.env.NOTION_PAGE_ID,
              path.join(rootDir, 'index.md'),
              baseTitle,
              true
            );
            if(baseResult) processed.add('index.md');

            console.log('== Fetching subpages ==');
            const subpages = await getSubpages(process.env.NOTION_PAGE_ID);
            const reserved = new Set(['about','index','portfolio','my-portfolio']);
            const slugCounts = new Map();

            for(const sub of subpages){
              const title = sub.child_page?.title || 'Untitled';
              let slug = slugify(title) || 'untitled';

              // Ensure uniqueness if duplicate slugs
              if(slugCounts.has(slug)){
                const n = slugCounts.get(slug) + 1;
                slugCounts.set(slug, n);
                slug = slug + '-' + n;
              } else {
                slugCounts.set(slug, 0);
              }

              if(reserved.has(slug.replace(/-\d+$/,''))){
                const baseSlug = slug.replace(/-\d+$/,'');
                console.log('[RESERVED] Handling ' + slug + ' as top-level page');
                if(baseSlug === 'portfolio' || baseSlug === 'my-portfolio'){
                  const portfolioResult = await convertPageToMarkdown(sub.id, path.join(rootDir, 'portfolio.md'), title, true);
                  if(portfolioResult) processed.add('portfolio.md');

                  // NEW: Recursively process portfolio child pages as project pages
                  console.log('[PORTFOLIO] Fetching child pages inside portfolio');
                  const portfolioChildren = await getSubpages(sub.id);
                  for (const pchild of portfolioChildren) {
                    const pTitle = pchild.child_page?.title || 'Untitled';
                    let pSlug = slugify(pTitle) || 'untitled';

                    // uniqueness with existing slugCounts map
                    if(slugCounts.has(pSlug)) {
                      const n = slugCounts.get(pSlug) + 1;
                      slugCounts.set(pSlug, n);
                      pSlug = pSlug + '-' + n;
                    } else {
                      slugCounts.set(pSlug, 0);
                    }

                    // skip reserved (avoid overwriting top-level pages)
                    if(reserved.has(pSlug)) {
                      console.log('[PORTFOLIO][SKIP-RESERVED] ' + pSlug);
                      continue;
                    }

                    const pOutFile = path.join(projectsDir, pSlug + '.md');
                    console.log('[PORTFOLIO][PROJECT] Converting nested project: ' + pTitle + ' -> ' + pOutFile);
                    const pResult = await convertPageToMarkdown(pchild.id, pOutFile, pTitle, true);
                    if(pResult) processed.add(path.join('projects', pSlug + '.md'));
                  }
                } else if (baseSlug === 'about') {
                  const aboutResult = await convertPageToMarkdown(sub.id, path.join(rootDir, 'about.md'), title, true);
                  if(aboutResult) processed.add('about.md');
                }
                continue;
              }

              const outFile = path.join(projectsDir, slug + '.md');
              const result = await convertPageToMarkdown(sub.id, outFile, title);
              if(result) processed.add(path.join('projects', slug + '.md'));
            }

            console.log('== Summary ==');
            console.log('Processed: ' + Array.from(processed).join(', '));
            console.log('Total pages written/checked: ' + processed.size);
          }

          await main().catch(e => { console.error('Fatal error in main()', e); process.exit(1); });
          EOL

      - name: Run conversion
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          NOTION_PAGE_ID: ${{ secrets.NOTION_PAGE_ID }}
        run: node convert.js

      - name: Commit changes
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add src/content/
          git commit -m "Update Notion content" || echo "No changes to commit"

      - name: Push changes
        uses: ad-m/github-push-action@master
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ github.ref }}
